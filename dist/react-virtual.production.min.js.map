{"version":3,"file":"react-virtual.production.min.js","sources":["../node_modules/@reach/observe-rect/dist/observe-rect.esm.js","../src/useIsomorphicLayoutEffect.js","../src/useRect.js","../src/index.js"],"sourcesContent":["var props = ['bottom', 'height', 'left', 'right', 'top', 'width'];\n\nvar rectChanged = function rectChanged(a, b) {\n  if (a === void 0) {\n    a = {};\n  }\n\n  if (b === void 0) {\n    b = {};\n  }\n\n  return props.some(function (prop) {\n    return a[prop] !== b[prop];\n  });\n};\n\nvar observedNodes =\n/*#__PURE__*/\nnew Map();\nvar rafId;\n\nvar run = function run() {\n  var changedStates = [];\n  observedNodes.forEach(function (state, node) {\n    var newRect = node.getBoundingClientRect();\n\n    if (rectChanged(newRect, state.rect)) {\n      state.rect = newRect;\n      changedStates.push(state);\n    }\n  });\n  changedStates.forEach(function (state) {\n    state.callbacks.forEach(function (cb) {\n      return cb(state.rect);\n    });\n  });\n  rafId = window.requestAnimationFrame(run);\n};\n\nfunction observeRect(node, cb) {\n  return {\n    observe: function observe() {\n      var wasEmpty = observedNodes.size === 0;\n\n      if (observedNodes.has(node)) {\n        observedNodes.get(node).callbacks.push(cb);\n      } else {\n        observedNodes.set(node, {\n          rect: undefined,\n          hasRectChanged: false,\n          callbacks: [cb]\n        });\n      }\n\n      if (wasEmpty) run();\n    },\n    unobserve: function unobserve() {\n      var state = observedNodes.get(node);\n\n      if (state) {\n        // Remove the callback\n        var index = state.callbacks.indexOf(cb);\n        if (index >= 0) state.callbacks.splice(index, 1); // Remove the node reference\n\n        if (!state.callbacks.length) observedNodes[\"delete\"](node); // Stop the loop\n\n        if (!observedNodes.size) cancelAnimationFrame(rafId);\n      }\n    }\n  };\n}\n\nexport default observeRect;\n//# sourceMappingURL=observe-rect.esm.js.map\n","import React from 'react'\n\nexport default typeof window !== 'undefined'\n  ? React.useLayoutEffect\n  : React.useEffect\n","import React from 'react'\n\nimport observeRect from '@reach/observe-rect'\n\nimport useIsomorphicLayoutEffect from './useIsomorphicLayoutEffect'\n\nexport default function useRect(nodeRef) {\n  const [element, setElement] = React.useState(nodeRef.current)\n  const [rect, dispatch] = React.useReducer(rectReducer, null)\n  const initialRectSet = React.useRef(false)\n\n  useIsomorphicLayoutEffect(() => {\n    if (nodeRef.current !== element) {\n      setElement(nodeRef.current)\n    }\n  })\n\n  useIsomorphicLayoutEffect(() => {\n    if (element && !initialRectSet.current) {\n      initialRectSet.current = true\n      const rect = element.getBoundingClientRect();\n      dispatch({ rect });\n    }\n  }, [element])\n\n  React.useEffect(() => {\n    if (!element) {\n      return\n    }\n\n    const observer = observeRect(element, rect => {\n      dispatch({ rect });\n    });\n\n    observer.observe()\n\n    return () => {\n      observer.unobserve()\n    }\n  }, [element])\n\n  return rect\n}\n\nfunction rectReducer(state, action) {\n  const rect = action.rect\n  if (!state || state.height !== rect.height || state.width !== rect.width) {\n    return rect\n  }\n  return state\n}\n\n","import React from 'react'\n\nimport useRect from './useRect'\nimport useIsomorphicLayoutEffect from './useIsomorphicLayoutEffect'\n\nconst defaultEstimateSize = () => 50\nconst defaultKeyExtractor = index => index\n\nexport function useVirtual({\n  size = 0,\n  estimateSize = defaultEstimateSize,\n  overscan = 0,\n  paddingStart = 0,\n  paddingEnd = 0,\n  parentRef,\n  horizontal,\n  scrollToFn,\n  useObserver,\n  onScrollElement,\n  scrollOffsetFn,\n  keyExtractor = defaultKeyExtractor,\n}) {\n  const sizeKey = horizontal ? 'width' : 'height'\n  const scrollKey = horizontal ? 'scrollLeft' : 'scrollTop'\n  const latestRef = React.useRef({})\n  const useMeasureParent = useObserver || useRect\n\n  const { [sizeKey]: outerSize } = useMeasureParent(parentRef) || {\n    [sizeKey]: 0,\n  }\n\n  const defaultScrollToFn = React.useCallback(\n    offset => {\n      if (parentRef.current) {\n        parentRef.current[scrollKey] = offset\n      }\n    },\n    [parentRef, scrollKey]\n  )\n\n  const resolvedScrollToFn = scrollToFn || defaultScrollToFn\n\n  scrollToFn = React.useCallback(\n    offset => {\n      resolvedScrollToFn(offset, defaultScrollToFn)\n    },\n    [defaultScrollToFn, resolvedScrollToFn]\n  )\n\n  const [measuredCache, setMeasuredCache] = React.useState({})\n\n  const measurements = React.useMemo(() => {\n    const measurements = []\n    for (let i = 0; i < size; i++) {\n      const measuredSize = measuredCache[keyExtractor(i)]\n      const start = measurements[i - 1] ? measurements[i - 1].end : paddingStart\n      const size =\n        typeof measuredSize === 'number' ? measuredSize : estimateSize(i)\n      const end = start + size\n      measurements[i] = { index: i, start, size, end }\n    }\n    return measurements\n  }, [estimateSize, keyExtractor, measuredCache, paddingStart, size])\n\n  const totalSize = (measurements[size - 1]?.end || 0) + paddingEnd\n\n  Object.assign(latestRef.current, {\n    overscan,\n    measurements,\n    outerSize,\n    totalSize,\n  })\n\n  const [range, setRange] = React.useState({ start: 0, end: 0 })\n\n  const element = onScrollElement ? onScrollElement.current : parentRef.current\n  useIsomorphicLayoutEffect(() => {\n    if (!element) {\n      return\n    }\n\n    const onScroll = () => {\n      const scrollOffset = scrollOffsetFn\n        ? scrollOffsetFn()\n        : element[scrollKey]\n      latestRef.current.scrollOffset = scrollOffset\n      setRange(prevRange => calculateRange(latestRef.current, prevRange))\n    }\n\n    // Determine initially visible range\n    onScroll()\n\n    element.addEventListener('scroll', onScroll, {\n      capture: false,\n      passive: true,\n    })\n\n    return () => {\n      element.removeEventListener('scroll', onScroll)\n    }\n  }, [element, scrollKey, size /* required */, outerSize /* required */])\n\n  const virtualItems = React.useMemo(() => {\n    const virtualItems = []\n    const end = Math.min(range.end, measurements.length - 1)\n\n    for (let i = range.start; i <= end; i++) {\n      const measurement = measurements[i]\n\n      const item = {\n        ...measurement,\n        measureRef: el => {\n          const { scrollOffset } = latestRef.current\n\n          if (el) {\n            const { [sizeKey]: measuredSize } = el.getBoundingClientRect()\n\n            if (measuredSize !== item.size) {\n              if (item.start < scrollOffset) {\n                defaultScrollToFn(scrollOffset + (measuredSize - item.size))\n              }\n\n              setMeasuredCache(old => ({\n                ...old,\n                [keyExtractor(i)]: measuredSize,\n              }))\n            }\n          }\n        },\n      }\n\n      virtualItems.push(item)\n    }\n\n    return virtualItems\n  }, [\n    range.end,\n    range.start,\n    measurements,\n    sizeKey,\n    defaultScrollToFn,\n    keyExtractor,\n  ])\n\n  const mountedRef = React.useRef()\n\n  useIsomorphicLayoutEffect(() => {\n    if (mountedRef.current) {\n      if (estimateSize) setMeasuredCache({})\n    }\n    mountedRef.current = true\n  }, [estimateSize])\n\n  const scrollToOffset = React.useCallback(\n    (toOffset, { align = 'start' } = {}) => {\n      const { scrollOffset, outerSize } = latestRef.current\n\n      if (align === 'auto') {\n        if (toOffset <= scrollOffset) {\n          align = 'start'\n        } else if (scrollOffset >= scrollOffset + outerSize) {\n          align = 'end'\n        } else {\n          align = 'start'\n        }\n      }\n\n      if (align === 'start') {\n        scrollToFn(toOffset)\n      } else if (align === 'end') {\n        scrollToFn(toOffset - outerSize)\n      } else if (align === 'center') {\n        scrollToFn(toOffset - outerSize / 2)\n      }\n    },\n    [scrollToFn]\n  )\n\n  const tryScrollToIndex = React.useCallback(\n    (index, { align = 'auto', ...rest } = {}) => {\n      const { measurements, scrollOffset, outerSize } = latestRef.current\n\n      const measurement = measurements[Math.max(0, Math.min(index, size - 1))]\n\n      if (!measurement) {\n        return\n      }\n\n      if (align === 'auto') {\n        if (measurement.end >= scrollOffset + outerSize) {\n          align = 'end'\n        } else if (measurement.start <= scrollOffset) {\n          align = 'start'\n        } else {\n          return\n        }\n      }\n\n      const toOffset =\n        align === 'center'\n          ? measurement.start + measurement.size / 2\n          : align === 'end'\n          ? measurement.end\n          : measurement.start\n\n      scrollToOffset(toOffset, { align, ...rest })\n    },\n    [scrollToOffset, size]\n  )\n\n  const scrollToIndex = React.useCallback(\n    (...args) => {\n      // We do a double request here because of\n      // dynamic sizes which can cause offset shift\n      // and end up in the wrong spot. Unfortunately,\n      // we can't know about those dynamic sizes until\n      // we try and render them. So double down!\n      tryScrollToIndex(...args)\n      requestAnimationFrame(() => {\n        tryScrollToIndex(...args)\n      })\n    },\n    [tryScrollToIndex]\n  )\n\n  return {\n    virtualItems,\n    totalSize,\n    scrollToOffset,\n    scrollToIndex,\n  }\n}\n\nfunction calculateRange(\n  { overscan, measurements, outerSize, scrollOffset },\n  prevRange\n) {\n  const total = measurements.length\n  let start = total - 1\n  while (start > 0 && measurements[start].end >= scrollOffset) {\n    start -= 1\n  }\n  let end = 0\n  while (\n    end < total - 1 &&\n    measurements[end].start <= scrollOffset + outerSize\n  ) {\n    end += 1\n  }\n\n  // Always add at least one overscan item, so focus will work\n  start = Math.max(start - overscan, 0)\n  end = Math.min(end + overscan, total - 1)\n\n  if (!prevRange || prevRange.start !== start || prevRange.end !== end) {\n    return { start, end }\n  }\n\n  return prevRange\n}\n"],"names":["rafId","props","observedNodes","Map","run","changedStates","state","node","a","b","newRect","getBoundingClientRect","rect","some","prop","cb","window","React","useLayoutEffect","useEffect","useRect","nodeRef","useState","current","element","setElement","useReducer","rectReducer","dispatch","initialRectSet","useRef","useIsomorphicLayoutEffect","observer","observe","wasEmpty","undefined","hasRectChanged","callbacks","unobserve","index","length","size","cancelAnimationFrame","action","height","width","defaultEstimateSize","defaultKeyExtractor","estimateSize","overscan","paddingStart","paddingEnd","parentRef","horizontal","scrollToFn","useObserver","onScrollElement","scrollOffsetFn","keyExtractor","sizeKey","scrollKey","latestRef","outerSize","defaultScrollToFn","useCallback","offset","resolvedScrollToFn","measuredCache","setMeasuredCache","measurements","useMemo","i","measuredSize","start","end","totalSize","Object","assign","range","setRange","onScroll","scrollOffset","prevRange","total","Math","max","min","calculateRange","addEventListener","capture","passive","removeEventListener","virtualItems","item","measureRef","el","old","push","mountedRef","scrollToOffset","toOffset","align","tryScrollToIndex","rest","measurement","scrollToIndex","args","requestAnimationFrame"],"mappings":"+fAAA,IAaAA,EAbIC,EAA2B,CAAA,SAAA,SAAA,OAAA,QAAA,MAA/B,SAYIC,EAAgB,IAApBC,IAGIC,EAAM,SAANA,QACIC,EAAN,GACAH,EAAAA,SAAsB,SAAAI,EAAAC,OARNC,EAAAC,EASVC,EAAUH,EAAdI,wBATcH,EAUCE,EAVDD,EAUWH,EAAzBM,UAVe,IAAAJ,IAAAA,EAAA,SAA4B,IAAAC,IAAAA,EAAA,IAC7CR,EAAAY,MAAW,SAAAC,UAAQN,EAAAM,KAAYL,EAAZK,QAUfR,EAAAA,KAAAA,EACAD,EAAAA,KAAAA,OAIJA,EAAAA,SAAsB,SAAAC,GACpBA,EAAAA,UAAAA,SAAwB,SAAAS,UAAMA,EAAGT,EAAHM,YAGhCZ,EAAQgB,OAAAA,sBAARhB,UC3B+B,oBAAXgB,OAClBC,EAAMC,gBACND,EAAME,UCEK,SAASC,EAAQC,SACAJ,EAAMK,SAASD,EAAQE,SAA9CC,OAASC,SACSR,EAAMS,WAAWC,EAAa,MAAhDf,OAAMgB,OACPC,EAAiBZ,EAAMa,QAAO,UAEpCC,GAA0B,WACpBV,EAAQE,UAAYC,GACtBC,EAAWJ,EAAQE,YAIvBQ,GAA0B,cACpBP,IAAYK,EAAeN,QAAS,CACtCM,EAAeN,SAAU,MACnBX,EAAOY,EAAQb,wBACrBiB,EAAS,CAAEhB,KAAAA,OAEZ,CAACY,IAEJP,EAAME,WAAU,cACTK,OFOPjB,EACAQ,EEJQiB,GFGRzB,EEH+BiB,EFI/BT,EEJwC,SAAAH,GACpCgB,EAAS,CAAEhB,KAAAA,KFKR,CACLqB,QAAAA,eACMC,EAAJ,IAAehC,EAAAA,KACXA,EAAAA,IAAJK,GACEL,EAAAA,IAAAA,GAAAA,UAAAA,KAAAA,GAEAA,EAAAA,IAAAA,EAAwB,CACtBU,UADsBuB,EAEtBC,gBAFsB,EAGtBC,UAAW,CAAAtB,KAGfmB,GAAc9B,KAGhBkC,UAAS,eACHhC,EAAQJ,EAAAA,IAAZK,MACAD,EAAW,KAEHiC,EAAQjC,EAAAA,UAAAA,QAAdS,GACIwB,GAAJ,GAAgBjC,EAAAA,UAAAA,OAAAA,EAHP,GAMJA,EAAAA,UAALkC,QAA6BtC,EAAa,OANjCK,GASJL,EAALuC,MAAyBC,qBAAAA,cE5B7BV,EAASC,UAEF,WACLD,EAASM,gBAEV,CAACd,IAEGZ,EAGT,SAASe,EAAYrB,EAAOqC,OACpB/B,EAAO+B,EAAO/B,YACfN,GAASA,EAAMsC,SAAWhC,EAAKgC,QAAUtC,EAAMuC,QAAUjC,EAAKiC,MAG5DvC,EAFEM,EC1CX,IAAMkC,EAAsB,kBAAM,IAC5BC,EAAsB,SAAAR,UAASA,gBAE9B,wBACLE,KAAAA,aAAO,QACPO,aAAAA,aAAeF,QACfG,SAAAA,aAAW,QACXC,aAAAA,aAAe,QACfC,WAAAA,aAAa,IACbC,IAAAA,UACAC,IAAAA,WACAC,IAAAA,WACAC,IAAAA,YACAC,IAAAA,gBACAC,IAAAA,mBACAC,aAAAA,aAAeX,IAETY,EAAUN,EAAa,QAAU,SACjCO,EAAYP,EAAa,aAAe,YACxCQ,EAAY5C,EAAMa,OAAO,IAGZgC,IAFMP,GAAenC,GAEUgC,YAC/CO,GAAU,MADJA,GAIHI,EAAoB9C,EAAM+C,aAC9B,SAAAC,GACMb,EAAU7B,UACZ6B,EAAU7B,QAAQqC,GAAaK,KAGnC,CAACb,EAAWQ,IAGRM,EAAqBZ,GAAcS,EAEzCT,EAAarC,EAAM+C,aACjB,SAAAC,GACEC,EAAmBD,EAAQF,KAE7B,CAACA,EAAmBG,UAGoBjD,EAAMK,SAAS,IAAlD6C,OAAeC,OAEhBC,EAAepD,EAAMqD,SAAQ,mBAC3BD,EAAe,GACZE,EAAI,EAAGA,EAAI9B,EAAM8B,IAAK,KACvBC,EAAeL,EAAcT,EAAaa,IAC1CE,EAAQJ,EAAaE,EAAI,GAAKF,EAAaE,EAAI,GAAGG,IAAMxB,EACxDT,EACoB,iBAAjB+B,EAA4BA,EAAexB,EAAauB,GAC3DG,EAAMD,EAAQhC,EACpB4B,EAAaE,GAAK,CAAEhC,MAAOgC,EAAGE,MAAAA,EAAOhC,KAAAA,EAAMiC,IAAAA,UAEtCL,IACN,CAACrB,EAAcU,EAAcS,EAAejB,EAAcT,IAEvDkC,aAAaN,EAAa5B,EAAO,aAAIiC,MAAO,GAAKvB,EAEvDyB,OAAOC,OAAOhB,EAAUtC,QAAS,CAC/B0B,SAAAA,EACAoB,aAAAA,EACAP,UAAAA,EACAa,UAAAA,UAGwB1D,EAAMK,SAAS,CAAEmD,MAAO,EAAGC,IAAK,IAAnDI,OAAOC,OAERvD,EAAUgC,EAAkBA,EAAgBjC,QAAU6B,EAAU7B,QACtEQ,GAA0B,cACnBP,OAICwD,EAAW,eACTC,EAAexB,EACjBA,IACAjC,EAAQoC,GACZC,EAAUtC,QAAQ0D,aAAeA,EACjCF,GAAS,SAAAG,UAmJf,WAEEA,OADEjC,IAAAA,SAAUoB,IAAAA,aAAcP,IAAAA,UAAWmB,IAAAA,aAG/BE,EAAQd,EAAa7B,OACvBiC,EAAQU,EAAQ,OACbV,EAAQ,GAAKJ,EAAaI,GAAOC,KAAOO,GAC7CR,GAAS,MAEPC,EAAM,OAERA,EAAMS,EAAQ,GACdd,EAAaK,GAAKD,OAASQ,EAAenB,GAE1CY,GAAO,KAITD,EAAQW,KAAKC,IAAIZ,EAAQxB,EAAU,GACnCyB,EAAMU,KAAKE,IAAIZ,EAAMzB,EAAUkC,EAAQ,IAElCD,GAAaA,EAAUT,QAAUA,GAASS,EAAUR,MAAQA,QACxD,CAAED,MAAAA,EAAOC,IAAAA,UAGXQ,EA5KmBK,CAAe1B,EAAUtC,QAAS2D,cAI1DF,IAEAxD,EAAQgE,iBAAiB,SAAUR,EAAU,CAC3CS,SAAS,EACTC,SAAS,IAGJ,WACLlE,EAAQmE,oBAAoB,SAAUX,OAEvC,CAACxD,EAASoC,EAAWnB,EAAqBqB,QAEvC8B,EAAe3E,EAAMqD,SAAQ,mBAC3BsB,EAAe,GACflB,EAAMU,KAAKE,IAAIR,EAAMJ,IAAKL,EAAa7B,OAAS,cAE7C+B,OAGDsB,SAFcxB,EAAaE,QAI/BuB,WAAY,SAAAC,OACFd,EAAiBpB,EAAUtC,QAA3B0D,gBAEJc,EAAI,KACavB,EAAiBuB,EAAGpF,wBAA9BgD,GAELa,IAAiBqB,EAAKpD,OACpBoD,EAAKpB,MAAQQ,GACflB,EAAkBkB,GAAgBT,EAAeqB,EAAKpD,OAGxD2B,GAAiB,SAAA4B,uBACZA,cACFtC,EAAaa,IAAKC,cAO7BoB,EAAaK,KAAKJ,IAzBXtB,EAAIO,EAAML,MAAOF,GAAKG,EAAKH,MAA3BA,UA4BFqB,IACN,CACDd,EAAMJ,IACNI,EAAML,MACNJ,EACAV,EACAI,EACAL,IAGIwC,EAAajF,EAAMa,SAEzBC,GAA0B,WACpBmE,EAAW3E,SACTyB,GAAcoB,EAAiB,IAErC8B,EAAW3E,SAAU,IACpB,CAACyB,QAEEmD,EAAiBlF,EAAM+C,aAC3B,SAACoC,uBAAgC,MAApBC,MAAAA,aAAQ,YACiBxC,EAAUtC,QAAtC0D,IAAAA,aAAcnB,IAAAA,UAER,SAAVuC,IAEAA,EADED,GAAYnB,EACN,QACCA,GAAgBA,EAAenB,EAChC,MAEA,SAIE,UAAVuC,EACF/C,EAAW8C,GACQ,QAAVC,EACT/C,EAAW8C,EAAWtC,GACH,WAAVuC,GACT/C,EAAW8C,EAAWtC,EAAY,KAGtC,CAACR,IAGGgD,EAAmBrF,EAAM+C,aAC7B,SAACzB,sBAAqC,SAA5B8D,MAAAA,aAAQ,SAAWE,sJACuB1C,EAAUtC,QAApD8C,IAAAA,aAAcY,IAAAA,aAAcnB,IAAAA,UAE9B0C,EAAcnC,EAAae,KAAKC,IAAI,EAAGD,KAAKE,IAAI/C,EAAOE,EAAO,QAE/D+D,MAIS,SAAVH,KACEG,EAAY9B,KAAOO,EAAenB,EACpCuC,EAAQ,UACH,CAAA,KAAIG,EAAY/B,OAASQ,UAC9BoB,EAAQ,YAMND,EACM,WAAVC,EACIG,EAAY/B,MAAQ+B,EAAY/D,KAAO,EAC7B,QAAV4D,EACAG,EAAY9B,IACZ8B,EAAY/B,MAElB0B,EAAeC,KAAYC,MAAAA,GAAUE,OAEvC,CAACJ,EAAgB1D,IAGbgE,EAAgBxF,EAAM+C,aAC1B,sCAAI0C,2BAAAA,kBAMFJ,eAAoBI,GACpBC,uBAAsB,WACpBL,eAAoBI,QAGxB,CAACJ,UAGI,CACLV,aAAAA,EACAjB,UAAAA,EACAwB,eAAAA,EACAM,cAAAA"}